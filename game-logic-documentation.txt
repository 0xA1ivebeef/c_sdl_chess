

TODO:   

KEY CONCEPTS:

-> keep engine, ui, ai and game loop seperate and interface them as needed

engine = pure rules (working with position - legal moves, check, mate etc., adjusting the position struct (making moves))
ui = interaction / display
ai = move decisions
game loop = orchestrator

-> components should be stateless to be modular, reusable and organized
-> there is one struct to represent a position that gets passed into the modules 
    which return the relative goal they are supposed to achive (legal moves, attack bitboard etc.)
-> modules should be divided into sub modules that only receive what they need for the calculations 
    and return the results back to the caller to move on there (tree structure instead of pipeline)

1. game is loaded with all assets and starting position (FEN)
    renderer, game flags etc. (loading struct "position") setting up engine and ui and gameloop

2. moving logic:
    switch player
    update occ
    generate enemy attack bitboard
    delete and generate legal moves
    filter legal moves for checks 
    render game

    - program is in a still state where it waits for inputs of a move
    - either automated move from opponent (also in update()) or manual input 
    -> get in a move from any interface (player, random legal move, evaluation etc.)   
    -> handle_move (bitboards, startsquare, destsquare, legal_moves, gameflags)
    handles a move given as startsquare and destsquare, all additional special move properties and checks for the move beeing legal
    -> calls apply_move(bitboards, startsquare, destsquare) which updates the bitboards

* for a manual move there are additional tests for selecting a piece
    but generally it calls handle_move(game, startsquare, destsquare, game flags)
    handle move returns 1 if a move was made, this invokes the update function
    (+ unselecting piece and rendering)


// Game loop example:
while (ui.game_running) 
{
    poll_input(&ui, &pos);

    if (pos.side_to_move == AI_COLOR) 
    {
        Move best = ai_search(&pos, depth);
        make_move(&pos, best);  // Engine handles the mutation
        ui.needs_update = true;
    }

    if (ui.move_selected) 
    {
        make_move(&pos, ui.move);  // Player move
        ui.needs_update = true;
    }

    if (ui.needs_update) 
    {
        render(&app, &pos, &ui);
        ui.needs_update = false;
    }
}


